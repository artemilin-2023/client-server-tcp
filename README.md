# Лабораторная работа по веб-технологиям

Лабораторная работа №2
Отчет доступен по [ссылке (добавлю позже)](http://127.0.0.1:80)

Перемещение:

- [Логгер](#логгер)
  - [Описание](#описание)
  - [Использование](#использование)
  - [Известные проблемы](#известные-проблемы)
- [Описание проекта](#описание-проекта)
- [Установка и запуск](#установка-и-запуск)
  - [Docker](#docker)
  - [Из исходников](#из-исходников)

# Логгер

Если у меня будет свободное время, то я создам github-wiki страницу и перенесу этот раздел туда.

## Описание

Моя библиотека для логирования. Поддерживает логирование в файл или консоль, фильтрацию по уровню ведения логов, синхронные и асинхронные методы, а так же конфигурацию с помощью json файла, что позволяет изменить параметры логирования, не пересобирая проект.

## Использование

Для упрощения восприятия кода, я не буду использовать операторы верхнего уровня. Так же не будут указываться неймспейсы:

```C#
using Logger;
using Logger.Abstracts;
```

LoggerFabric
------------

За настройку и создание объекта логгера, отвечает класс ```LoggerFabric```. После конфигурации воспользуйтесь методом ```Build```, чтобы
получить объект типа ```ILogger```:

```C#
LoggerFabric fabric = new LoggerFabric();
fabric.SetLogLevel(LogLevel.Debug);

ILogger logger = fabric.Build();
```

```LogLevel``` - **обязательный** параметр во всех случаях. Если будет указан только он, то метод ```Build``` вернет консольный логгер, если указать ```File```, то вернется файловый логгер.
Для конфигурации логгера воспользуйтесь методами ```SetBasePath```, ```SetFile```, ```SetLogLevel```:

```C#
var fabric = new LoggerFabric();
fabric.SetLogLevel(LogLevel.Debug); // Устанавливает уровень логирования.
fabric.SetBasePath("./path/to/folder"); // Устанавливает путь до папки, в которой бует лог-файл.
fabric.SetFile("file_name.log"); // Устанавливает имя для лог-файла.

var logger = fabric.Build();
```

Так же поддерживается возможность конфигурации из json файла с помощью метода ```SetJsonConfiguration```:

```C#
var fabric = new LoggerFabric();
fabric.SetJsonConfiguration("./path/to/configuration.json");
```

Формат файла конфигурации:

```
{
    "Logging":{
        "Folder": string,
        "File": string,
        "LogLevel": string // Одно из: [Debug, Info, Warning, Error, Fatal]
    }
}
```

Альтернативный способ конфигурации логгера с помощью каскадного вызова методов:

```C#
ILogger logger = new LoggerFabric()
    .SetBasePath("./Logs")
    .SetFile("logs.log")
    .SetLogLevel(LogLevel.Info)
    .Build();
```

ILogger
-------

```ILogger``` - интерфейс, описывающий взаимодействие с логгером.

```C#
ILogger logger = new LoggerFabric().SetLogLevel(LogLevel.Debug).Build();

// Синхронные методы:
logger.Debug("debug"); // output: [Debug] - 01.01.2024 23:23:59 | debug
logger.Info("info");
logger.Warn("warning");
logger.Error("error");
logger.Fatal("fatal");


// Асинхронные методы:
await logger.DebugAsync("debug");
await logger.InfoAsync("info");
await logger.WarnAsync("warning");
await logger.ErrorAsync("error");
await logger.FatalAsync("fatal");
```

Формат вывода: ```[LogLevel] - dd.mm.yyyy hh:mm:ss | your_message```

LogLevel
--------

```LogLevel``` - перечисление доступных уровней логирования. Фильтрация происходит по следующему принципу: выводятся логи указанного уровня и всех уровней ниже.

```C#
Debug = 0,
Info = 1,
Warning = 2,
Error = 3,
Fatal = 4
```

## Известные проблемы

Асинхронная запись в файл осуществляется "вперемешку" (скорее всего из-за отсутсвия синхронизации потоков). Поэтому в проекте используется синхронная потокобезопасная версия методов.

# Описание проекта

Моя реализация клиент-серверного TCP взаимодействия на сокетах для лаболаторной роботы №2 по веб-технологиям. Клиент написан на языке Python, сервер - на C#. Мне не хотелось погружаться в питон, поэтому клиент выглядит, мягко говоря, не очень. В многопоточной асинхронной версии сервера каждый клиент обрабатывается в своем потоке, тем самым не блокируя сервер. Чтение из потока на стороне сервера осуществляется по следующему принципу: ```считывается длина сообщения``` -> ```считывается сообщение указанной длины```. Такой способ помогает избежать ситуаций, когда часть сообщения ещё не пришла (например, из-за сетевой задержки), а мы уже закончили считывание данных. На клиент сообщение отправляется просто "как есть", без указания длины, так как, опять таки, мне не хотелось уделять много времени клиенту на питоне.

# Установка и запуск

## Docker?

Пока не готово (и не факт, что я это сделаю, но пункт оставлю, как напоминание)

## Из исходников

### Ubuntu

Шаг 1 - установка зависимостей
```
sudo apt-get update && sudo apt-get upgrade && \
sudo apt-get install -y dotnet-sdk-8.0 && \
sudo apt-get install -y python3.1 && \
sudo apt-get install -y git
```

Шаг 2 - скачиваем репозиторий
```
git clone https://github.com/artemilin-2023/client-server-tcp.git
cd ./client-server-tcp/
```

Шаг 3 - компилируем библиотеку логирования